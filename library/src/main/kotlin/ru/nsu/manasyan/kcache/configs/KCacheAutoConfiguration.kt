package ru.nsu.manasyan.kcache.configs

import com.google.gson.Gson
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean
import org.springframework.boot.context.properties.EnableConfigurationProperties
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Import
import ru.nsu.manasyan.kcache.aspect.KCacheableAspect
import ru.nsu.manasyan.kcache.aspect.UpdateStateAspect
import ru.nsu.manasyan.kcache.core.ETagBuilder
import ru.nsu.manasyan.kcache.core.RequestStatesMapper
import ru.nsu.manasyan.kcache.core.StateHolder
import ru.nsu.manasyan.kcache.defaults.ConcatenateETagBuilder
import ru.nsu.manasyan.kcache.defaults.RamRequestStatesMapper
import ru.nsu.manasyan.kcache.properties.HazelcastProperties
import ru.nsu.manasyan.kcache.properties.KCacheProperties
import ru.nsu.manasyan.kcache.properties.RedisProperties
import ru.nsu.manasyan.kcache.util.LoggerProperty

/**
 * Auto configuration class for SpringBoot starter
 */
@Configuration
@Import(StateHolderConfiguration::class)
// TODO: refactor
@EnableConfigurationProperties(
    value = [
        KCacheProperties::class,
        RedisProperties::class,
        HazelcastProperties::class
    ]
)
class KCacheAutoConfiguration {
    private val logger by LoggerProperty()

    /**
     * Creates [RequestStatesMapper] bean.
     * Instance was obtained by deserialization from file, generated by KCacheable annotation processor.
     */
    @Bean
    @ConditionalOnBean(value = [StateHolder::class])
    fun requestStatesMapping(): RequestStatesMapper {
        val mappingsFile = this::class.java.classLoader.getResource(
            RequestStatesMapper.MAPPINGS_FILE_PATH
        )

        return mappingsFile?.let {
            Gson().fromJson(it.readText(), RamRequestStatesMapper::class.java)
        } ?: RamRequestStatesMapper()
    }

    /**
     * Creates [InjectStatesBeanPostProcessor] bean
     */
    @Bean
    @ConditionalOnBean(value = [RequestStatesMapper::class])
    fun injectStatesBeanPostProcessor(
        requestStatesMapper: RequestStatesMapper
    ): InjectStatesBeanPostProcessor {
        return InjectStatesBeanPostProcessor(requestStatesMapper)
    }

    /**
     * Creates default [ETagBuilder] bean if
     * there is [StateHolder] instance in context
     * and there are no another [ETagBuilder] beans
     */
    @Bean
    @ConditionalOnMissingBean
    @ConditionalOnBean(value = [StateHolder::class])
    fun eTagBuilder(stateHolder: StateHolder): ETagBuilder {
        logger.debug("Building ConcatenateETagBuilder")
        return ConcatenateETagBuilder(stateHolder)
    }

    /**
     * Creates [KCacheableAspect] bean if
     * there are no [StateHolder] and [ETagBuilder] beans in context
     */
    @Bean
    @ConditionalOnBean(value = [StateHolder::class, ETagBuilder::class])
    fun kCacheAspect(
        eTagBuilder: ETagBuilder,
        requestStatesMapper: RequestStatesMapper
    ): KCacheableAspect {
        logger.debug("Building KCacheAspect")
        return KCacheableAspect(eTagBuilder, requestStatesMapper)
    }

    /**
     * Creates [UpdateStateAspect] bean if
     * there are [StateHolder] and [ETagBuilder] beans in context
     */
    @Bean
    @ConditionalOnBean(value = [StateHolder::class, ETagBuilder::class])
    fun updateStateAspect(
        stateHolder: StateHolder,
    ): UpdateStateAspect {
        logger.debug("Building UpdateStateAspect")
        return UpdateStateAspect(stateHolder)
    }

}